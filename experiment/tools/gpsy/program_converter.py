import math
import os

from gpsy.primitive_set import PrimitiveSet
from gpsy.node import Node


# Useful path directory.
root_dir = (f'{os.path.dirname(os.path.abspath(__file__))}/../../results/'
            f'programs')


# Define some GP functions.

def add(x1, x2):
    """Return result of addition."""
    return x1 + x2

def aq(x1, x2):
    """Return result of analytical quotient.
    
    The analytical quotient is as defined by Ni et al. in their paper 
    'The use of an analytic quotient operator in genetic programming':  
    `aq(x1, x2) = (x1)/(sqrt(1+x2^(2)))`.
    """
    return (x1) / (math.sqrt(1 + x2 ** (2)))

def exp(x): 
    """Return result of exponentiation, base `e`."""
    return math.exp(x)

def log(x):
    """Return result of protected logarithm, base `e`."""
    if x != 0:
        return math.log(abs(x))
    else:
        return 0

def mul(x1, x2):
    """Return result of multiplication."""
    return x1 * x2

def sin(x):
    """Return result of sine."""
    return math.sin(x)

def sqrt(x):
    """Return result of protected square root."""
    try:
        return math.sqrt(x)
    except ValueError:
        # Input is negative.
        return 0

def sub(x1, x2):
    """Return result of subtraction."""
    return x1 - x2

def tanh(x):
    """Return result of hyperbolic tangent."""
    return math.tanh(x)


# Primitive set names.
names = ('nicolau_a', 'nicolau_b', 'nicolau_c')

# Function sets.
functions = ((add, mul, sub, aq),
             (add, mul, sub, aq, sin, tanh),
             (add, mul, sub, aq, exp, log, sqrt, sin, tanh))

# Constant sets.
constants = []
for name in names:
    with open(f'{root_dir}/{name}/constants.txt', 'r') as f:
        constants.append(f.read().splitlines())

# Tuples for maximum program size and 'size bin' size.
sizes = ((255, 2), (63, 1), (63, 1))

# Number of programs per size bin.
num_programs_per_bin = 1

# Primitive sets.
primitive_sets = {name: PrimitiveSet() for name in names}
for name, functions, constants in zip(names, functions, constants):
    for f in functions:
        primitive_sets[name].add_function(f)
    for _ in range(len(functions)-1):
        primitive_sets[name].add_variable_terminal()
    for c in constants:
        primitive_sets[name].add_constant_terminal(c)

# Retrieve and convert programs to various notations.
for (name, ps), (max_size, bin_size) in zip(primitive_sets.items(), sizes):

    # Retrieve programs generated by DEAP.
    with open(f'{root_dir}/{name}/programs_deap.txt', 'r') as f:
        programs = f.read().splitlines()

    # Convert to `Node` objects.
    programs = [Node.from_str(p) for p in programs]

    ####################################################################

    # Convert to Operon strings.
    programs_ = [p.inorder_str for p in programs]

    # Write Operon programs.
    with open(f'{root_dir}/{name}/programs_operon.txt', 'w+') as f:
        for p in programs_:
            f.write(f'{p}\n')

    ####################################################################

    # Convert to TensorGP strings.
    programs_ = [p.tensorgp_str(ps) for p in programs]

    # Write TensorGP programs.
    with open(f'{root_dir}/{name}/programs_tensorgp.txt', 'w+') as f:
        for p in programs_:
            f.write(f'{p}\n')

    ####################################################################

    # For each size bin, convert `num_programs_per_bin` programs to 
    # the relevant assembly language.

    # Maximum number of program memory locations.
    # An extra memory location is given for 'null' separators.
    depth = (max_size+1)*num_programs_per_bin

    # Address and data widths for assembly language, base 16.
    addr_width = int(math.ceil(math.log(depth, 16)))
    data_width = int(math.ceil(math.log(len(ps.assembly_language), 16)))

    for i in range(1, int(math.ceil(max_size/bin_size))+1):
        # Programs for bin `i`.
        bin = programs[(i-1)*num_programs_per_bin:(i)*num_programs_per_bin]
        with open(
            f'{root_dir}/{name}/mif/programs_bin{i}.mif', 'w+') as f:
            # Write MIF header.
            f.write(f'DEPTH = {depth};\n')
            f.write(f'WIDTH = {data_width};\n')
            f.write(f'ADDRESS RADIX = HEX;\n')
            f.write(f'DATA RADIX = HEX;\n')
            f.write(f'CONTENT\n')
            f.write(f'BEGIN\n\n')

            # Write MIF data.
            for j, program in enumerate(bin):
                # For each program...
                for k, node in enumerate(program.preorder + ('null',)):
                    # For each node...
                    addr = j * (max_size+1) + k
                    f.write(f'{addr:0{addr_width}X} : '
                            f'{ps.opcode(node, "X")};\n')
                if k < max_size:
                    # The current program did not utilize all 
                    # of its allocated memory; initialize the 
                    # remainder of the relevant program memory 
                    # locations to zero.
                    addrl = j * (max_size+1) + (k+1)
                    addrh = (j+1) * max_size
                    f.write(f'[{addrl:0{addr_width}X}..'
                            f'{addrh:0{addr_width}X}] : '
                            f'{0:0{data_width}X};\n')
            f.write(f'\nEND;')